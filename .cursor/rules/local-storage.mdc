---
description: 
globs: 
alwaysApply: false
---
# 🧱 Règle de structure pour la gestion des données (Next.js + Firebase + Zustand)

Ce document décrit la règle standardisée à suivre pour la création de code dans notre application utilisant **Next.js**, **Firebase (Firestore)** et **Zustand**.

---

## 🎯 Objectif

Assurer une structure **cohérente**, **scalable** et **maintenable** entre :
- les données Firestore,
- les stores Zustand (cache local),
- les composants React.

---

## ✅ Règle en 4 étapes (à suivre pour chaque entité)

> Exemple d’entité : `Project`, `Event`, `User`...

---

### 🔹 Étape 1 – Définir le type TypeScript

📁 `types/index.ts`

```ts
export type Project = {
  id: string;
  name: string;
  ownerId: string;
  createdAt: Date;
};
```

### 🔹 Étape 2 – Créer le hook Firestore générique
📁 `hooks/useFirestoreDoc.ts`

```ts
export function useFirestoreDoc<T>(
  collection: string,
  id: string,
  opts?: { realtime?: boolean }
): { data: T | null; loading: boolean }
```

- Utilise getDoc() ou onSnapshot()
- Centralise la logique d’accès aux données Firestore
- Option possible pour activer le cache Zustand

### 🔹 Étape 3 – Créer un hook spécifique par entité
📁 `hooks/useProject.ts`

```ts
import { useFirestoreDoc } from './useFirestoreDoc';
import { Project } from '@/types';

export function useProject(projectId: string) {
  return useFirestoreDoc<Project>('projects', projectId, { realtime: true });
}
```

- Ce hook est utilisé dans les composants
- Il encapsule la logique de Firestore pour une entité spécifique

### 🔹 Étape 4 – Gérer le cache Zustand (optionnel)
📁 `store/cacheStore.ts`

```ts
type CacheStore = {
  projects: Record<string, Project>;
  setProject: (id: string, project: Project) => void;
};
```

- Ce store peut être lu ou mis à jour par useFirestoreDoc si opts.cache === true
Permet d’éviter les appels réseau inutiles
