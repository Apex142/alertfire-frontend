---
description: 
globs: 
alwaysApply: false
---
# ğŸ§± RÃ¨gle de structure pour la gestion des donnÃ©es (Next.js + Firebase + Zustand)

Ce document dÃ©crit la rÃ¨gle standardisÃ©e Ã  suivre pour la crÃ©ation de code dans notre application utilisant **Next.js**, **Firebase (Firestore)** et **Zustand**.

---

## ğŸ¯ Objectif

Assurer une structure **cohÃ©rente**, **scalable** et **maintenable** entre :
- les donnÃ©es Firestore,
- les stores Zustand (cache local),
- les composants React.

---

## âœ… RÃ¨gle en 4 Ã©tapes (Ã  suivre pour chaque entitÃ©)

> Exemple dâ€™entitÃ© : `Project`, `Event`, `User`...

---

### ğŸ”¹ Ã‰tape 1 â€“ DÃ©finir le type TypeScript

ğŸ“ `types/index.ts`

```ts
export type Project = {
  id: string;
  name: string;
  ownerId: string;
  createdAt: Date;
};
```

### ğŸ”¹ Ã‰tape 2 â€“ CrÃ©er le hook Firestore gÃ©nÃ©rique
ğŸ“ `hooks/useFirestoreDoc.ts`

```ts
export function useFirestoreDoc<T>(
  collection: string,
  id: string,
  opts?: { realtime?: boolean }
): { data: T | null; loading: boolean }
```

- Utilise getDoc() ou onSnapshot()
- Centralise la logique dâ€™accÃ¨s aux donnÃ©es Firestore
- Option possible pour activer le cache Zustand

### ğŸ”¹ Ã‰tape 3 â€“ CrÃ©er un hook spÃ©cifique par entitÃ©
ğŸ“ `hooks/useProject.ts`

```ts
import { useFirestoreDoc } from './useFirestoreDoc';
import { Project } from '@/types';

export function useProject(projectId: string) {
  return useFirestoreDoc<Project>('projects', projectId, { realtime: true });
}
```

- Ce hook est utilisÃ© dans les composants
- Il encapsule la logique de Firestore pour une entitÃ© spÃ©cifique

### ğŸ”¹ Ã‰tape 4 â€“ GÃ©rer le cache Zustand (optionnel)
ğŸ“ `store/cacheStore.ts`

```ts
type CacheStore = {
  projects: Record<string, Project>;
  setProject: (id: string, project: Project) => void;
};
```

- Ce store peut Ãªtre lu ou mis Ã  jour par useFirestoreDoc si opts.cache === true
Permet dâ€™Ã©viter les appels rÃ©seau inutiles
